# Writing a PLUGIN

[Note: the code of `sequence` may change continually, so do not use this as reference - this document is
incomplete and will become obsolete, but the structure and logic holds.]

## Overview

We illustrate how to write a plugin by creating one for searching for sequences in full text. We allow for a variety, DNA
RNA, 3-letter protein, 1-letter protein, Carbohydrates. It should be easily modifiable and upgradable.

We need to create the following interdependent components. The naming is important and inconsistencies will cause problems. We
take `sequence` as the unique "plugin name". It will occur in at least:

 * configuration filenames (e.g. `/org/xmlcml/ami2/plugins/sequence/args.xml`. This drives the operation of the program. It's a path relative to the Java classpath and is usually found as `src/main/resources/org/xmlcml/ami2/plugins/sequence/args.xml`. 
 * autogenerated directories `my_file/some_where/results/sequence/dna/results.xml`. `my_file/some_where/` is a QSN directory, abd after the calculation, the plugin `sequence`  generates (or uses an existing) `results` (reserved name) directory. Then it generates the subdirectory `sequence` (using the plugin name) and then plugin-specific subsubdirectories.
 * classes (e.g. `org.xmlcml.ami2.plugins.sequence.SequenceArgProcessor`). The functionality of `args.xml` and the Java class must be carefully matched (see below)
 * argument definitions in `args.xml`. These will be used to control action and generate files and will frequently use the pluginName.
 
We shall build checkers and autogenerators to aid consistency, but for now be extra careful and check. 

## Inheritance

We have the following inheritance hierarchy (discussed in detail in  and AMI.md)

```
    DefaultArgProcessor
        AMIArgProcessor
            SequenceArgProcessor
```

### DefaultArgProcessor

This contains all generic parsing software, general flow , input and output. See DEFAULT.md)

### AMIArgProcessor

This contains generic plugin parsing software, such as text contexts, output options, choice of inputs. See AMI.md)

## design

### requirements

We want to control at least

 * The type of sequence
 * the lengths of sequences
 * lookup in repositories
 
###filestructure

The directory structure is dictated by the `maven` architecture:
 ```
 src
 	main
 		java
 			org
 				xmlcml
 					ami2
 						plugins
 							sequence
	 							SequenceArgProcessor
		resources
			org
				xmlcml
					ami2
						plugins
							sequence
								args.xml
	test
 		java
 			org
 				xmlcml
 					ami2
 						plugins
 							sequence
	 							SequenceArgProcessorTest
		resources
			org
				xmlcml
					ami2
						plugins
							sequence
								<test file data>
								
```
If you are creating a new plugin DO PLEASE use a Java-aware IDE (Eclipse, IntelliJ, Netbeans, etc.) They understand maven and will get  the structure correct. For a simple class you can create all the files this way. The `test` directories are ESSENTIAL; no-one should create this code without them. They drive TestDrivenDevelopment (TDD), act as regression tests, and provide useful examples.

## args.xml

Much of the generic functionality (input, parsing, etc.) is inherited, so we can concentrate on the functionallity for sequences. The structure of the file is

```
<argList name="sequence">
    <arg name="type" ...>
    <arg name="..." >
</argList>
```

Each arg represents a possible argument (starting with `-` or `--`). It has a name, constraints on occurrence numbers, constraints on values, Java type, default values, actions when triggered, etc.

### Sequence type

This describes the biological type of the sequence. (Note we'll use lowercase throughout). We'll do this through a `pattern` which allows only listed keywords. We'll only allow one type at present - if you want to search for DNA and Protein, run independent searches - they can always be merged later. Note that the attributes (name="value") can be in any order but the same attribute name cannot occur more than once.

```
<arg name="type"
    brief="-sq.t"
    long="--sq.type"
    args="type"
    default="dna"
    class="java.lang.String"
    pattern="(dna|rna|prot|prot3|carb3)"
    parseMethod="parseType"
    countRange="{1,1}"
    >
    <help>
    The type of the sequence. All sequences are 1-letter unless they have a trailing digit.
    </help>
```

Comments:

 * the `name` must be unique in this plugin and may be useful to create output subdirectories
 * the flags (`brief` and `long`) must be unique within the job. `long` is mandatory and recommended; it starts with 2 minus signs. `brief` cannot normally be condensed to single letters (which themselves cannot be concatenated). 
 * `args` is a semi-formatted string to prompt the user on possible arguments.
 * `default` provides a default value which must be of the same class as the argument value, and must be consistent with any constraints.
 * `class` is the Java data type of the argument value. By default it is a `String` (of text) - formally `java.lang.String`. Other common `java.lang.*` values are `Boolean`, `Integer` and `Double`. 
 * `pattern` is a constraint on the argument values. In this case it's a regular expression describing an enumeration of allowed values.
 * `countRange` constraints the number of values for the argument. In this case it's minimum of 1, maximum of 1, so 1.
 * `parseMethod` is mandatory for every argument, and names the Java class used to parse this argument. In many cases it's a single line assigning the value (although it can be more complex).
 
 ### sequence length
 
 To constrain the length of the sequence we can set minimum and/or maximum length. "don't care" is represented by `*`. Examples:
 
  * `countRange="{6,20}"`   sequences of length 6 to 20 inclusive
  * `countRange="{*,20}"`   sequences of length up to 20 
  * `countRange="{6,*}"`   sequences of length 6 or more
  * `countRange="{*,*}"`   sequences of any length 
  
  The `<arg>` looks  like
  
  ```
<arg name="length"
    brief="-sq.l"
    long="--sq.length"
    args="lengthRange"
    default="{1,*}"
    class="org.xmlcml.euclid.IntRange"
    parseMethod="parseLength"
    countRange="{1,1}"
    >
    <help>
    The allowed length of the sequence, described by a single org.xmlcml.euclid.IntRange (note there are no internal spaces). The default is `{1,*}` - any non-empty sequence - will be used if there is no `--sq.length` attribute. When this attribute is present, the method `parseLength` will be called which saves the value of the `IntRange`.
    </help>
```

### running and control

The plugin search.mine action is given by a method in the `run` phase
  ```
<arg name="sequence"
    long="--sq.sequence"
    args=""
    runMethod="runSearch"
    countRange="{0,0}"
    >
    <help>
    This runs the search - there are no argument values. 
    </help>
```
## SequenceArgProcessor
  
This has to:

 * parse the arguments and store the values and workflow
 * run the methods for searching/mining sequences
 * output results
 * optionally summarize the process
 * optionally gather parallel searches
 
 The main class `SequenceArgProcessor` has key components:

All plugins at present extend `AMIArgProcessor`
 
```
public class SequenceArgProcessor extends AMIArgProcessor {
```

Plugins have a Logger (log4j) which defaults to outputting DEBUG:
```	
	public static final Logger LOG = Logger.getLogger(WordArgProcessor.class);
	static {
		LOG.setLevel(Level.DEBUG);
	}
```
We omit details of constants and local variables as they are specific to each plugin.

Two constructors [the `super()` and `this()` are redundant but added to show the logic]

```
	public WordArgProcessor() {
		super();
	}

	public WordArgProcessor(String[] args) {
		this();
		parseArgs(args);
	}

```
The first is used if we do not wish to parse the arguments; the second is often used to parse the arguments immediately.

`args.xml` has indicated 2 parsing methods and we include them here. They are called by "reflection" and must have the exact signatures shown.

```
	// =============== METHODS ==============

	/** select methods to use
	 * 
	 * @param option 
	 * @param argIterator
	 */
	public void parseSequence(ArgumentOption option, ArgIterator argIterator) {
		List<String> tokens = argIterator.createTokenListUpToNextNonDigitMinus(option);
		if (tokens.size() == 0) {
			helpMethods();
		} else {
			chosenMethods = getChosenList(ANALYSIS_METHODS, tokens);
		}
	}

  
